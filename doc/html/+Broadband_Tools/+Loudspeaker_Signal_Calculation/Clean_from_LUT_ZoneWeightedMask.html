<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of Clean_from_LUT_ZoneWeightedMask</title>
  <meta name="keywords" content="Clean_from_LUT_ZoneWeightedMask">
  <meta name="description" content="Clean_from_LUT_ZoneWeightedMask Summary of this function goes here">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">+Broadband_Tools</a> &gt; <a href="index.html">+Loudspeaker_Signal_Calculation</a> &gt; Clean_from_LUT_ZoneWeightedMask.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for +Broadband_Tools\+Loudspeaker_Signal_Calculation&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>Clean_from_LUT_ZoneWeightedMask
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Clean_from_LUT_ZoneWeightedMask Summary of this function goes here</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function Clean_from_LUT_ZoneWeightedMask( Input_file, LUT_resolution, Noise_Mask_dB, weight, setup ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">Clean_from_LUT_ZoneWeightedMask Summary of this function goes here
   Detailed explanation goes here</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function Clean_from_LUT_ZoneWeightedMask( Input_file, LUT_resolution, Noise_Mask_dB, weight, setup )</a>
0002 <span class="comment">%Clean_from_LUT_ZoneWeightedMask Summary of this function goes here</span>
0003 <span class="comment">%   Detailed explanation goes here</span>
0004 
0005 <span class="comment">%% Setup Variables</span>
0006 [Input_file_path, Input_file_name, Input_file_ext] = fileparts( Input_file );
0007 Input_file_path = [Input_file_path <span class="string">'\'</span>];
0008 
0009 Fs = 16000; <span class="comment">% Sampling frequency</span>
0010 Nfft = 1024;<span class="comment">% Number of fft components</span>
0011 overlap = 0.5;
0012 f_low  = 150;  <span class="comment">% Hz</span>
0013 f_high = 8000; <span class="comment">% Hz</span>
0014 
0015 leakage_angle = 0; <span class="comment">% Angle of the leaked planewave into the quiet so that planewave noise can mask the signal</span>
0016 angle_pw       = setup.Multizone_Soundfield.Bright_Zone.SourceOrigin.Angle;
0017 loudspeakers   = setup.Loudspeaker_Count;
0018 speaker_arc    = setup.Speaker_Arc_Angle;
0019 speaker_radius = setup.Radius;
0020 
0021 Drive = <span class="string">'Z:\'</span>;
0022 Output_file_path     = [Drive <span class="string">'+Speaker_Signals\'</span>]; <span class="comment">% Can be relative or exact</span>
0023 Output_file_path_ext = [<span class="string">'+'</span> num2str(speaker_radius*2) <span class="string">'m_SpkrDia\+'</span> num2str(loudspeakers) <span class="string">'Spkrs_'</span> num2str(speaker_arc) <span class="string">'DegArc_LUT_'</span> LUT_resolution <span class="string">'\'</span>];
0024 SetupInfo            = [<span class="string">'_'</span> num2str(f_low ) <span class="string">'Hz-'</span> <span class="keyword">...</span>
0025     num2str(f_high) <span class="string">'Hz_'</span> <span class="keyword">...</span>
0026     num2str(angle_pw) <span class="string">'pwAngle_'</span> <span class="keyword">...</span>
0027     num2str(Noise_Mask_dB) <span class="string">'dB_'</span> <span class="keyword">...</span>
0028     num2str(weight) <span class="string">'weight__withZoneWeightMask'</span>];
0029 Output_file_name     = [Input_file_name <span class="string">'__'</span> <span class="keyword">...</span>
0030     num2str(loudspeakers) <span class="string">'spkrs_'</span> <span class="keyword">...</span>
0031     SetupInfo];
0032 Output_file_ext      = <span class="string">'.WAV'</span>;
0033 
0034 
0035 
0036 
0037 
0038 <span class="comment">% Read input signal</span>
0039 Input_Signal = audioread( [Input_file_path Input_file_name Input_file_ext] );
0040 
0041 <span class="keyword">for</span> sig = 1:2 <span class="comment">% Firstly we compute the loudspeaker signals for the input signal then we compute the loudspeaker signals for the additive zone weighted noise</span>
0042     
0043     <span class="comment">%% Firstly, find the frequency domain representation of an audio file that is wished to be reproduced in the spatial domain.</span>
0044     [Z, Frequencies_, ~, Windows] = Broadband_Tools.FFT_custom_vec(Input_Signal, Nfft, Fs, overlap);
0045     
0046     <span class="comment">% Truncate to frequencies in the range f_low &lt;-&gt; f_high</span>
0047     trunc_index_low  = find(Frequencies_ &lt; f_low , 1, <span class="string">'last'</span> ) + 1;
0048     trunc_index_high = find(Frequencies_ &gt; f_high, 1 ) + 1;
0049     <span class="keyword">if</span> isempty(trunc_index_low)
0050         trunc_index_low = 1;
0051     <span class="keyword">end</span>
0052     <span class="keyword">if</span> isempty(trunc_index_high)
0053         trunc_index_high = length(Frequencies_);
0054     <span class="keyword">end</span>
0055     <span class="comment">%Z = Z ( :, trunc_index_low:trunc_index_high );</span>
0056     Frequencies_ = Frequencies_( :, trunc_index_low:trunc_index_high );
0057     
0058     <span class="comment">% Work out the coresponding number of planewaves for these frequencies</span>
0059     f_samples = length(Frequencies_);   
0060     
0061     
0062     
0063     
0064     
0065     
0066     
0067     
0068     
0069     <span class="comment">%% Secondly, build a flat spectra desired multizone soundfield for all frequencies from the previous fft and save the speaker signals for each frequency bin.</span>
0070     <span class="keyword">if</span> sig == 1
0071         load([Drive <span class="string">'+Soundfield_Database\+'</span> num2str(speaker_radius*2) <span class="string">'m_SpkrDia\+'</span> num2str(loudspeakers) <span class="string">'Spkrs_'</span> num2str(speaker_arc) <span class="string">'DegArc\LUT_Weight_vs_Frequency_'</span> num2str(angle_pw) <span class="string">'deg_'</span> LUT_resolution <span class="string">'.mat'</span>]);
0072     <span class="keyword">elseif</span> sig == 2
0073         load([Drive <span class="string">'+Soundfield_Database\+'</span> num2str(speaker_radius*2) <span class="string">'m_SpkrDia\+'</span> num2str(loudspeakers) <span class="string">'Spkrs_'</span> num2str(speaker_arc) <span class="string">'DegArc\LUT_Weight_vs_Frequency_'</span> num2str(leakage_angle) <span class="string">'deg_'</span> LUT_resolution <span class="keyword">...</span>
0074             <span class="string">'_zones_swapped.mat'</span>]);
0075     <span class="keyword">end</span>
0076     
0077     <span class="comment">%Loudspeaker capable LUT available?</span>
0078     <span class="keyword">if</span> ~exist(<span class="string">'Loudspeaker_Weights__Weight_Vs_Frequency'</span>,<span class="string">'var'</span>)
0079         error(<span class="string">'A Look-Up Table with valid Loudspeaker Weights was not found. Please either choose another LUT or generate a valid LUT.'</span>);
0080     <span class="keyword">end</span>
0081     
0082     
0083     [szW, szF] = size(Loudspeaker_Weights__Weight_Vs_Frequency);
0084     LUT_Loudspeaker_Weights = cell2mat(Loudspeaker_Weights__Weight_Vs_Frequency);
0085     LUT_Loudspeaker_Weights = permute( reshape(LUT_Loudspeaker_Weights, loudspeakers, szW, szF), [2 3 1] );
0086     
0087     
0088     <span class="comment">% When interpolating the angle of the complex loudspeaker weight we need to phase unwrap otherwise</span>
0089     <span class="comment">% the interpolation may become close to 180 degrees out of phase which will</span>
0090     <span class="comment">% cause contructive interference instead of destructive and vise versa</span>
0091     Loudspeaker_Weights = zeros(length(Frequencies_),loudspeakers);
0092     <span class="keyword">for</span> spkr = 1:loudspeakers
0093         Loudspeaker_Weights(:,spkr) = permute( Tools.interpVal_2D(LUT_Loudspeaker_Weights(:,:,spkr), Frequencies, Weights, Frequencies_, weight, <span class="string">'spline'</span>), [2 1]);
0094         
0095         Loudspeaker_Weights(:,spkr) = permute( Tools.interpVal_2D(abs(LUT_Loudspeaker_Weights(:,:,spkr)), Frequencies, Weights, Frequencies_, weight, <span class="string">'spline'</span>), [2 1]) <span class="keyword">...</span>
0096             .* exp(1i * angle(Loudspeaker_Weights(:,spkr)));
0097         
0098     <span class="keyword">end</span>
0099     
0100     
0101     
0102         
0103     
0104     
0105     
0106     <span class="comment">%% Finally, apply the speaker weight and reconstruct the loudspeaker signals for each frame of the input signal</span>
0107     <span class="comment">%load(['+Soundfield_Database\+From_LUT\' Output_file_path_ext 'Weights_and_Samples__' SetupInfo '.mat']);</span>
0108     
0109     <span class="comment">% % Here we want to build the speaker signals for each speaker so that our loudspeaker weights are taken into account.</span>
0110     <span class="comment">% % We want to form the entire spectrum by adding the conjugate of the frame</span>
0111     <span class="comment">% % to the existing frame where the negative frequencies of the transform</span>
0112     <span class="comment">% % would usually exist.</span>
0113  Loudspeaker_Weights = [zeros(trunc_index_low-1, loudspeakers); <span class="keyword">...</span>
0114                         Loudspeaker_Weights; <span class="keyword">...</span>
0115                         zeros( size(Z,2) - trunc_index_high, loudspeakers)];                    
0116  Loudspeaker_Weights = permute( repmat(Loudspeaker_Weights, [1 1 size(Z,1)]), [3 1 2]);
0117  Z_l = repmat(Z, [1 1 loudspeakers]);
0118  
0119     <span class="comment">%</span>
0120     Loudspeakers_ = zeros( [size(Z_l,1) (size(Z_l,2))*2 size(Z_l,3)] );
0121     <span class="keyword">for</span> spkr = 1:loudspeakers
0122         Loudspeakers_(:,1:end/2,spkr) = Z_l(:,:,spkr) .* Loudspeaker_Weights(:,:,spkr);
0123         Loudspeakers_(:,end/2+1:<span class="keyword">end</span>,spkr) = conj( [-Loudspeakers_(:,1,spkr).*0 Loudspeakers_(:,end/2:-1:2,spkr)]);
0124     <span class="keyword">end</span>
0125     Original = [Z(:,:,1) conj( [-Z(:,1,1).*0 Z(:,end:-1:2,1)] )];
0126     <span class="comment">% clear Loudspeaker_Weights; % Save on memory</span>
0127     <span class="comment">%</span>
0128     <span class="comment">% % We then want to perform an Inverse FFT (ifft) on each full spectrum frame</span>
0129     <span class="keyword">for</span> frame = 1:size(Loudspeakers_, 1)
0130         <span class="keyword">for</span> spkr = 1:loudspeakers
0131             Loudspeakers_(frame,:,spkr) = ifft( Loudspeakers_(frame,:,spkr) );
0132         <span class="keyword">end</span>
0133         Original(frame,:) = ifft( Original(frame, :) );
0134     <span class="keyword">end</span>
0135     
0136     <span class="comment">%We should apply the second square root hamming window here</span>
0137     <span class="comment">%we should do this to remove artificats caused by our spectral</span>
0138     <span class="comment">%modification</span>
0139     <span class="comment">%for frame = 1:size(Loudspeakers_, 1)</span>
0140     <span class="keyword">for</span> spkr = 1:loudspeakers
0141         Loudspeakers_(:,:,spkr) = Loudspeakers_(:,:,spkr) .* Windows;
0142     <span class="keyword">end</span>
0143     Original = Original .* Windows;
0144     <span class="comment">%end</span>
0145     
0146     <span class="comment">%</span>
0147     <span class="comment">% % Then we should perform the overlap-add method to obtain the complete time domain signal for each speaker</span>
0148     <span class="comment">% %Loudspeaker_Signals =</span>
0149     <span class="comment">% zeros([(size(Z,1)+ceil(overlap))*size(Z,2)*2*(1-overlap) loudspeakers] ); % pre-allocate memory</span>
0150     <span class="keyword">for</span> spkr = 1:loudspeakers
0151         Loudspeaker_Signals(:,spkr) = Broadband_Tools.OverlapAdd( Loudspeakers_(:,:,spkr), overlap );
0152     <span class="keyword">end</span>
0153     Original_ = Broadband_Tools.OverlapAdd( Original, overlap );
0154     <span class="comment">% clear Loudspeakers_; % Save on memory</span>
0155     
0156     
0157     <span class="comment">% Scale signals so they don't clip upon saving</span>
0158     <span class="keyword">if</span> Noise_Mask_dB &lt;= 0
0159         scaler = 1 / (db2mag(0)+1); <span class="comment">%Plus one is for the amplitude of the clean signal</span>
0160     <span class="keyword">elseif</span> Noise_Mask_dB &gt; 0 <span class="comment">% For a positive masker we scale the signals to save up to a 40db noise masker</span>
0161         scaler = 1 / (db2mag(40)+1);<span class="comment">%Plus one is for the amplitude of the clean signal</span>
0162     <span class="keyword">end</span>
0163     
0164     <span class="comment">% Normalise Loudspeaker Signals</span>
0165     Loudspeaker_Signals = Loudspeaker_Signals ./ max(abs(Loudspeaker_Signals(:)))  *  scaler; 
0166     Original_ = Original_ ./ max(abs(Original_(:)))  *  scaler;
0167     
0168     <span class="keyword">if</span> sig == 1
0169         Loudspeaker_Signals_Input_Signal = Loudspeaker_Signals;
0170         Original_Input_Signal = Original_;
0171     <span class="keyword">end</span>
0172     
0173     Input_Signal = Tools.generateNoise(Loudspeaker_Signals, Noise_Mask_dB, <span class="string">'WGN'</span>); <span class="comment">% Generate noise to put back into the system and zone weight according to the multizone setup</span>
0174     
0175 <span class="keyword">end</span>
0176 Original_ = Original_Input_Signal;
0177 
0178 <span class="comment">%% Add Zone Weighted Noise Loudspeaker Signals to Speech Loudspeaker Signals</span>
0179 
0180  <span class="comment">% Here we add our loudspeaker signals which reproduce our input signal and a relatively weighted 'zone weighted' noise</span>
0181  <span class="comment">% That is to say, we add the zone weighted noise to the reproduction,</span>
0182  <span class="comment">% however, the zone weighted noise can be varied in level such that 0dB is</span>
0183  <span class="comment">% when the peak noise is equal to the input signal reproduction.</span>
0184 Loudspeaker_Signals = Loudspeaker_Signals_Input_Signal + db2mag(Noise_Mask_dB) * Loudspeaker_Signals;
0185 
0186 
0187 
0188 
0189 
0190 
0191 <span class="comment">%% Once we have the speaker signals we should save them for later use as .wav files</span>
0192 filenumbers = num2str((1:loudspeakers)');
0193 filenumbers(filenumbers==<span class="string">' '</span>) = <span class="string">'_'</span>;
0194 fullpath = [repmat([Output_file_path Output_file_path_ext Output_file_name], [loudspeakers 1]) <span class="keyword">...</span>
0195     filenumbers <span class="keyword">...</span>
0196     repmat(Output_file_ext, [loudspeakers 1]) ];
0197 
0198 <span class="keyword">if</span> ~exist([Output_file_path Output_file_path_ext],<span class="string">'dir'</span>); mkdir([Output_file_path Output_file_path_ext]); <span class="keyword">end</span>
0199 
0200 <span class="keyword">for</span> spkr = 1:loudspeakers
0201     audiowrite(fullpath(spkr,:), Loudspeaker_Signals(:, spkr), Fs);
0202 <span class="keyword">end</span>
0203 audiowrite([Output_file_path Output_file_path_ext <span class="keyword">...</span>
0204     Input_file_name <span class="string">'__Original_'</span> <span class="keyword">...</span>
0205     num2str(f_low ) <span class="string">'Hz-'</span> <span class="keyword">...</span>
0206     num2str(f_high) <span class="string">'Hz'</span> <span class="keyword">...</span>
0207     Input_file_ext], Original_, Fs);
0208 
0209 
0210 
0211 
0212 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Sun 09-Jul-2017 20:35:18 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>