<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of getMSRLoudspeakerSignals</title>
  <meta name="keywords" content="getMSRLoudspeakerSignals">
  <meta name="description" content="GETLOUDSPEAKERSIGNALS Summary of this function goes here">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">+Broadband_Tools</a> &gt; <a href="index.html">+Loudspeaker_Signal_Calculation</a> &gt; getMSRLoudspeakerSignals.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for +Broadband_Tools\+Loudspeaker_Signal_Calculation&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>getMSRLoudspeakerSignals
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>GETLOUDSPEAKERSIGNALS Summary of this function goes here</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [ Loudspeaker_Signals, Original_ ] = getMSRLoudspeakerSignals( Input_Signal, setup, signal_info, system_info ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">GETLOUDSPEAKERSIGNALS Summary of this function goes here
   Detailed explanation goes here</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [ Loudspeaker_Signals, Original_ ] = getMSRLoudspeakerSignals( Input_Signal, setup, signal_info, system_info )</a>
0002 <span class="comment">%GETLOUDSPEAKERSIGNALS Summary of this function goes here</span>
0003 <span class="comment">%   Detailed explanation goes here</span>
0004 
0005 <span class="keyword">if</span> ~isfield(signal_info,<span class="string">'f_high_meas'</span>)
0006     signal_info.f_high_meas = signal_info.f_high;
0007 <span class="keyword">end</span>
0008 <span class="keyword">if</span> ~isfield(signal_info,<span class="string">'f_low_meas'</span>)
0009     signal_info.f_low_meas = signal_info.f_low;
0010 <span class="keyword">end</span>
0011 
0012 <span class="comment">%% First, Load the relevant look-up tables and check compatability</span>
0013 method = {<span class="string">'new4'</span>, <span class="string">'new3'</span>, <span class="string">'new2'</span>, <span class="string">'new'</span>};
0014 <span class="keyword">for</span> m = 1:2
0015     method_ = [method, {<span class="string">'old_zones_swapped'</span>}];
0016     [DB,err] = Soundfield_Database.loadDatabaseFromSetup( setup, system_info.LUT_resolution, system_info.Drive, method_{m} );
0017     <span class="keyword">if</span> ~err
0018         <span class="keyword">break</span>;
0019     <span class="keyword">end</span>
0020 <span class="keyword">end</span>
0021 
0022 <span class="comment">%Loudspeaker capable LUT available?</span>
0023 <span class="keyword">if</span> ~isfield(DB,<span class="string">'Loudspeaker_Weights__Weight_Vs_Frequency'</span>)
0024     error(<span class="string">'A Look-Up Table with valid Loudspeaker Weights was not found. Please either choose another LUT or generate a valid LUT.'</span>);
0025 <span class="keyword">end</span>
0026 
0027 Frequencies = DB.Frequencies;
0028 Weights = DB.Weights;
0029 
0030 <span class="comment">%% Find ideal weights</span>
0031 
0032 len = length(Input_Signal);
0033 noise_freqs = linspace(0, signal_info.Fs/2, len/2 + 1);
0034 noise_freqs = noise_freqs(noise_freqs&gt;=min(Frequencies) &amp; noise_freqs&lt;=max(Frequencies));
0035 
0036 len = signal_info.Nfft + signal_info.zeropadtime * signal_info.Fs;
0037 freqs = linspace(0, signal_info.Fs/2, len/2 + 1);
0038 freqs = freqs(freqs&gt;=min(Frequencies) &amp; freqs&lt;=max(Frequencies));
0039 
0040 <span class="keyword">if</span> ~strcmpi(signal_info.weight, <span class="string">'auto'</span>)
0041     noise_weights = repmat(signal_info.weight,1,length(noise_freqs));
0042     weights = repmat(signal_info.weight,1,length(freqs));
0043 <span class="keyword">else</span>
0044     <span class="comment">% Find the weights that will give us the biggest contrast possible</span>
0045     <span class="comment">% (works better at lower frequencies)</span>
0046     LUT_MagDiff = DB.Acoustic_Contrast__Weight_Vs_Frequency;<span class="comment">%DB.Bright_Sample__Weight_Vs_Frequency - DB.Quiet_Sample__Weight_Vs_Frequency;</span>
0047     
0048     <span class="comment">% Noise weights</span>
0049     LUT_MagDiff_interp = interp2(Frequencies,Weights,LUT_MagDiff,noise_freqs',Weights,<span class="string">'spline'</span>);
0050     [~,I]=max(LUT_MagDiff_interp);
0051     noise_weights = Weights(I);
0052     
0053     <span class="comment">%Signal Weights</span>
0054     LUT_MagDiff_interp = interp2(Frequencies,Weights,LUT_MagDiff,freqs',Weights,<span class="string">'spline'</span>);
0055     [~,I]=max(LUT_MagDiff_interp);
0056     weights = Weights(I);
0057 <span class="keyword">end</span>
0058 
0059 
0060 <span class="comment">%% Second, find the frequency domain representation of the audio file that is wished to be reproduced in the spatial domain.</span>
0061 si = signal_info;
0062 <span class="keyword">if</span> isempty(strfind(lower(signal_info.method),<span class="string">'cancel'</span>))
0063     si.time_delay = 0;
0064 <span class="keyword">end</span>
0065 [Z, Frqs, ~, Windows, Zo] = Broadband_Tools.FFT_custom( Input_Signal, si);
0066 
0067 <span class="comment">% Truncate to frequencies in the range f_low &lt;-&gt; f_high</span>
0068 iLo  = find(Frqs &lt; signal_info.f_low , 1, <span class="string">'last'</span> ) + 1;
0069 iHi = find(Frqs &gt; signal_info.f_high, 1 ) + 1;
0070 <span class="keyword">if</span> isempty(iLo)
0071     iLo = 1;
0072 <span class="keyword">end</span>
0073 <span class="keyword">if</span> isempty(iHi)
0074     iHi = length(Frqs);
0075 <span class="keyword">end</span>
0076 
0077 FI = iLo:iHi;
0078 Frequencies_ = Frqs( :, FI );
0079 
0080 <span class="comment">%     Frequencies_ = Frequencies_(Frequencies_&gt;=min(Frequencies) &amp; Frequencies_&lt;=max(Frequencies));</span>
0081 
0082 <span class="comment">%% Third, build a flat spectra desired multizone soundfield for all frequencies from the previous fft and save the speaker weights for each frequency bin.</span>
0083 [szW, szF] = size(DB.Loudspeaker_Weights__Weight_Vs_Frequency);
0084 LUT_Loudspeaker_Weights = cell2mat(DB.Loudspeaker_Weights__Weight_Vs_Frequency);
0085 LUT_Loudspeaker_Weights = permute( reshape(LUT_Loudspeaker_Weights, setup.Loudspeaker_Count, szW, szF), [2 3 1] );
0086 
0087 <span class="comment">% When interpolating the angle of the complex loudspeaker weight we need to phase unwrap otherwise</span>
0088 <span class="comment">% the interpolation may become close to 180 degrees out of phase which will</span>
0089 <span class="comment">% cause contructive interference instead of destructive and vise versa</span>
0090 Loudspeaker_Weights = zeros(length(Frequencies_),setup.Loudspeaker_Count);
0091 ind = 1:(iHi-iLo+1);
0092 <span class="keyword">for</span> spkr = 1:setup.Loudspeaker_Count
0093     LW = Tools.interpVal_2D(LUT_Loudspeaker_Weights(:,ind,spkr), Frequencies(ind), Weights, Frequencies_, weights, <span class="string">'spline'</span>);
0094     Loudspeaker_Weights(:,spkr) = LW(:);
0095     
0096     LW_abs = Tools.interpVal_2D( abs(LUT_Loudspeaker_Weights(:,ind,spkr)), Frequencies(ind), Weights, Frequencies_, weights, <span class="string">'spline'</span>);
0097     Loudspeaker_Weights(:,spkr) = LW_abs(:) <span class="keyword">...</span>
0098         .* exp(1i * angle(Loudspeaker_Weights(:,spkr)));
0099 <span class="keyword">end</span>
0100 
0101 
0102 <span class="comment">%% Finally, apply the speaker weight and reconstruct the loudspeaker signals for each frame of the input signal</span>
0103 <span class="comment">% % Here we want to build the speaker signals for each speaker so that our loudspeaker weights are taken into account.</span>
0104 <span class="comment">% % We want to form the entire spectrum by adding the conjugate of the frame</span>
0105 <span class="comment">% % to the existing frame where the negative frequencies of the transform</span>
0106 <span class="comment">% % would usually exist.</span>
0107 N = signal_info.Nfft;
0108 
0109 taperWin = tukeywin(N,(iLo+0.05*N)/N);
0110 
0111 <span class="comment">% test_Weights = [Loudspeaker_Weights(1,8).*ones(iLo-1, 1); ... %For bandpass filtering the original to maintain fair comparison</span>
0112 <span class="comment">%     Loudspeaker_Weights(:,8); ...</span>
0113 <span class="comment">%     zeros( N/2 - iHi, 1)];</span>
0114 
0115 Loudspeaker_Weights = [repmat(Loudspeaker_Weights(1,:),iLo-1,1); <span class="keyword">...</span>
0116     Loudspeaker_Weights;<span class="keyword">...</span>
0117     zeros( N/2 - iHi, setup.Loudspeaker_Count)];
0118 Orig_Weights = [ones(iLo-1, 1); <span class="keyword">...</span><span class="comment"> %For bandpass filtering the original to maintain fair comparison</span>
0119     ones(length(Frequencies_),1); <span class="keyword">...</span>
0120     zeros( N/2 - iHi, 1)];
0121 
0122 <span class="comment">% test_Weights = test_Weights .* taperWin;</span>
0123 <span class="comment">% Loudspeaker_Weights = Loudspeaker_Weights .* repmat(taperWin,1,setup.Loudspeaker_Count);</span>
0124 <span class="comment">% Orig_Weights = Orig_Weights .* taperWin;</span>
0125 
0126 Loudspeaker_Weights = permute( repmat(Loudspeaker_Weights, [1 1 size(Z,1)]), [3 1 2]);
0127 Orig_Weights = permute( repmat(Orig_Weights, [1 1 size(Zo,1)]), [3 1 2]);
0128 <span class="comment">% test_Weights = permute( repmat(test_Weights, [1 1 size(Z,1)]), [3 1 2]);</span>
0129 Z_l = repmat(Z, [1 1 setup.Loudspeaker_Count]);
0130 
0131 <span class="comment">%</span>
0132 Loudspeakers_ = zeros( [size(Z_l,1) (size(Z_l,2))*2 size(Z_l,3)] );
0133 <span class="keyword">for</span> spkr = 1:setup.Loudspeaker_Count
0134     Loudspeakers_(:,1:end/2,spkr) = Z_l(:,:,spkr) .* Loudspeaker_Weights(:,:,spkr);
0135     Loudspeakers_(:,end/2+1:<span class="keyword">end</span>,spkr) = conj( [-Loudspeakers_(:,1,spkr).*0 Loudspeakers_(:,end/2:-1:2,spkr)]);
0136 <span class="keyword">end</span>
0137 Original = [Zo(:,:,1) conj( [-Zo(:,1,1).*0 Zo(:,end:-1:2,1)] )] .* [Orig_Weights Orig_Weights(:,1) Orig_Weights(:,end:-1:2)];
0138 <span class="comment">%  Input_toMatch = [Z(:,:,1) conj( [-Z(:,1,1).*0 Z(:,end:-1:2,1)] )].* [test_Weights test_Weights(:,1) test_Weights(:,end:-1:2)];</span>
0139 
0140 <span class="comment">%</span>
0141 <span class="comment">% % We then want to perform an Inverse FFT (ifft) on each full spectrum frame</span>
0142 <span class="keyword">for</span> frame = 1:size(Loudspeakers_, 1)
0143     <span class="keyword">for</span> spkr = 1:setup.Loudspeaker_Count
0144         Loudspeakers_(frame,:,spkr) = ifft( Loudspeakers_(frame,:,spkr) * size(Loudspeakers_,2) );
0145     <span class="keyword">end</span>
0146 <span class="keyword">end</span>
0147 <span class="keyword">for</span> frame = 1:size(Original,1)
0148     Original(frame,:) = ifft( Original(frame, :) * size(Original,2) );
0149 <span class="keyword">end</span>
0150 <span class="comment">% for frame = 1:size(Input_toMatch,1)</span>
0151 <span class="comment">%     Input_toMatch(frame,:) = ifft( Input_toMatch(frame, :) * size(Input_toMatch,2) );</span>
0152 <span class="comment">% end</span>
0153 
0154 
0155 <span class="comment">%We should apply the second square root hamming window here</span>
0156 <span class="comment">%we should do this to remove artificats caused by our spectral</span>
0157 <span class="comment">%modification</span>
0158 <span class="comment">%for frame = 1:size(Loudspeakers_, 1)</span>
0159 <span class="keyword">for</span> spkr = 1:setup.Loudspeaker_Count
0160     Loudspeakers_(:,:,spkr) = Loudspeakers_(:,:,spkr) .* Windows;
0161 <span class="keyword">end</span>
0162 Original = Original .* Windows(1:size(Original,1),:);
0163 <span class="comment">% Input_toMatch = Input_toMatch .* Windows(1:size(Input_toMatch,1),:);</span>
0164 <span class="comment">%end</span>
0165 
0166 <span class="keyword">if</span> ~isempty(signal_info.zeropadtime)
0167     Npad=signal_info.zeropadtime * signal_info.Fs;
0168     Loudspeakers_(:,[1:Npad/2, end-Npad/2+1:end],:)=[];
0169     Original(:,[1:Npad/2, end-Npad/2+1:end],:)=[];
0170     <span class="comment">%     Input_toMatch(:,[1:Npad/2, end-Npad/2+1:end],:)=[];</span>
0171 <span class="keyword">end</span>
0172 
0173 <span class="comment">%</span>
0174 <span class="comment">% % Then we should perform the overlap-add method to obtain the complete time domain signal for each speaker</span>
0175 <span class="comment">% %Loudspeaker_Signals =</span>
0176 <span class="comment">% zeros([(size(Z,1)+ceil(overlap))*size(Z,2)*2*(1-overlap) setup.Loudspeaker_Count] ); % pre-allocate memory</span>
0177 <span class="keyword">for</span> spkr = 1:setup.Loudspeaker_Count
0178     <span class="comment">%     Loudspeaker_Signals(:,spkr) = Broadband_Tools.OverlapAdd( real(Loudspeakers_(:,:,spkr)), signal_info.overlap ); %#ok&lt;AGROW&gt;</span>
0179     Loudspeaker_Signals(:,spkr) = overlapadd( squeeze(real(Loudspeakers_(:,:,spkr))), ones(signal_info.Nfft,1), (1-signal_info.overlap)*signal_info.Nfft  ); <span class="comment">%#ok&lt;AGROW&gt;</span>
0180     Loudspeaker_Signals(isnan(Loudspeaker_Signals(:,spkr)),spkr)=0;
0181 <span class="keyword">end</span>
0182 <span class="comment">% Original_ = Broadband_Tools.OverlapAdd( Original, signal_info.overlap );</span>
0183 Original_ = overlapadd( Original, ones(signal_info.Nfft,1), (1-signal_info.overlap)*signal_info.Nfft  ); <span class="comment">%#ok&lt;AGROW&gt;</span>
0184 <span class="comment">% Input_toMatch_ = overlapadd( Input_toMatch, ones(signal_info.Nfft,1), (1-signal_info.overlap)*signal_info.Nfft  ); %#ok&lt;AGROW&gt;</span>
0185 <span class="comment">% Input_toMatch_ = Broadband_Tools.OverlapAdd( Input_toMatch, signal_info.overlap );</span>
0186 <span class="comment">% clear Loudspeakers_; % Save on memory</span>
0187 
0188 
0189 
0190 <span class="comment">%%</span>
0191 <span class="comment">% if ~isempty(signal_info.time_delay)</span>
0192 <span class="comment">%     t_d = signal_info.time_delay;</span>
0193 <span class="comment">% else</span>
0194 <span class="comment">%     t_d = signal_info.Nfft/signal_info.Fs;</span>
0195 <span class="comment">% end</span>
0196 <span class="comment">%     t_d = signal_info.time_delay;</span>
0197 <span class="comment">% if t_d ~= 0 &amp;&amp; ~isempty(strfind(lower(signal_info.method),'cancel'))</span>
0198 <span class="comment">% if ~isempty(strfind(lower(signal_info.method),'cancel'))</span>
0199 <span class="keyword">if</span> signal_info.predict_buff ~= 0
0200     LS_=[];
0201     <span class="keyword">for</span> s=1:setup.Loudspeaker_Count
0202         LS = enframe(Loudspeaker_Signals(:,s),signal_info.Nfft/2,signal_info.Nfft/2);
0203         LS_(:,s) = reshape(LS(2:2:<span class="keyword">end</span>,:).',[],1);
0204     <span class="keyword">end</span>
0205     Loudspeaker_Signals = LS_;
0206     Loudspeaker_Signals(size(Loudspeaker_Signals,1):length(Original_),:)=0;
0207 <span class="keyword">end</span>
0208 <span class="comment">%     IM = enframe(Input_toMatch_,signal_info.Nfft/2,signal_info.Nfft/2);</span>
0209 <span class="comment">%     IM_ = reshape(IM(2:2:end,:).',[],1);</span>
0210 <span class="comment">%     Input_toMatch_ = IM_;</span>
0211 <span class="comment">%     Input_toMatch_(size(Input_toMatch_,1):length(Original_),:)=0;</span>
0212 <span class="comment">% end</span>
0213 <span class="comment">% s2=size(Loudspeaker_Signals,2);</span>
0214 <span class="comment">% Zs = zeros(t_d*signal_info.Fs,1);</span>
0215 <span class="comment">% if ~isempty(strfind(lower(signal_info.method),'cancel'))</span>
0216 <span class="comment">%     Loudspeaker_Signals = [repmat(Zs,1,s2); ...</span>
0217 <span class="comment">%         Loudspeaker_Signals];</span>
0218 <span class="comment">%     Original_ = [Original_; Zs];</span>
0219 <span class="comment">% else</span>
0220 <span class="comment">%     Loudspeaker_Signals = [Loudspeaker_Signals; ...</span>
0221 <span class="comment">%         repmat(Zs,1,s2)];</span>
0222 <span class="comment">%     Original_ = [Original_; Zs];</span>
0223 <span class="comment">% end</span>
0224 
0225 <span class="comment">%%</span>
0226 
0227 <span class="comment">% Scale signals so they don't clip upon saving</span>
0228 <span class="keyword">if</span> signal_info.L_noise_mask &lt;= 0
0229     scaler = 1 / (db2mag(0)+1); <span class="comment">%Plus one is for the amplitude of the clean signal</span>
0230 <span class="keyword">elseif</span> signal_info.L_noise_mask &gt; 0 <span class="comment">% For a positive masker we scale the signals to save up to a 40db noise masker</span>
0231     scaler = 1 / (db2mag(40)+1);<span class="comment">%Plus one is for the amplitude of the clean signal</span>
0232 <span class="keyword">end</span>
0233 
0234 <span class="comment">% Normalise Loudspeaker Signals</span>
0235 <span class="comment">% [~,adjVal] = Broadband_Tools.power_norm( Input_Signal(:), Input_toMatch_(:), signal_info.Fs, [signal_info.f_low_meas, signal_info.f_high_meas]);</span>
0236 Loudspeaker_Signals = Loudspeaker_Signals  *  scaler;
0237 
0238 
0239 <span class="keyword">end</span>
0240</pre></div>
<hr><address>Generated on Sun 09-Jul-2017 20:35:18 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>