<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of Clean_from_LUT_ZoneWeightedMask_AliasCtrl_StereoNoise</title>
  <meta name="keywords" content="Clean_from_LUT_ZoneWeightedMask_AliasCtrl_StereoNoise">
  <meta name="description" content="Clean_from_LUT_ZoneWeightedMask Summary of this function goes here">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">+Broadband_Tools</a> &gt; <a href="index.html">+Loudspeaker_Signal_Calculation</a> &gt; Clean_from_LUT_ZoneWeightedMask_AliasCtrl_StereoNoise.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for +Broadband_Tools\+Loudspeaker_Signal_Calculation&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>Clean_from_LUT_ZoneWeightedMask_AliasCtrl_StereoNoise
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Clean_from_LUT_ZoneWeightedMask Summary of this function goes here</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function Clean_from_LUT_ZoneWeightedMask_AliasCtrl_StereoNoise( Input_file, LUT_resolution, Noise_Mask_dB, weight, setup, leakage_angle_delta ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">Clean_from_LUT_ZoneWeightedMask Summary of this function goes here</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function y = applyWeight(x, W, W_freqs, Fs)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function Clean_from_LUT_ZoneWeightedMask_AliasCtrl_StereoNoise( Input_file, LUT_resolution, Noise_Mask_dB, weight, setup, leakage_angle_delta )</a>
0002 <span class="comment">%Clean_from_LUT_ZoneWeightedMask Summary of this function goes here</span>
0003 
0004 masker_type = <span class="string">'ZoneWeightMaskAliasCtrlStereoNoise'</span>;
0005 <span class="comment">%% Setup Variables</span>
0006 [Input_file_path, Input_file_name, Input_file_ext] = fileparts( Input_file );
0007 Input_file_path = [Input_file_path <span class="string">'\'</span>];
0008 
0009 Fs = 16000; <span class="comment">% Sampling frequency</span>
0010 Nfft = 1024;<span class="comment">% Number of fft components</span>
0011 overlap = 0.5;
0012 f_low  = 150;  <span class="comment">% Hz</span>
0013 f_high = 8000; <span class="comment">% Hz</span>
0014 
0015 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0016 leakage_angle = 0;
0017 <span class="comment">% STEREO NOISE</span>
0018 <span class="keyword">if</span> nargin &lt; 9
0019     leakage_angle_delta = 30; <span class="comment">% Angle to virtual stereo noise source from angle of intereference (leakage)</span>
0020 <span class="keyword">end</span>
0021 leakage_angle_L = leakage_angle + leakage_angle_delta;
0022 leakage_angle_R = leakage_angle - leakage_angle_delta;
0023 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0024 
0025 angle_pw       = setup.Multizone_Soundfield.Bright_Zone.SourceOrigin.Angle;
0026 loudspeakers   = setup.Loudspeaker_Count;
0027 speaker_arc    = setup.Speaker_Arc_Angle;
0028 speaker_radius = setup.Radius;
0029 
0030 Drive = <span class="string">'Z:\'</span>;
0031 Output_file_path     = [Drive <span class="string">'+Speaker_Signals\'</span>]; <span class="comment">% Can be relative or exact</span>
0032 Output_file_path_ext = [<span class="string">'+'</span> num2str(speaker_radius*2) <span class="string">'m_SpkrDia\+'</span> num2str(loudspeakers) <span class="string">'Spkrs_'</span> num2str(speaker_arc) <span class="string">'DegArc_LUT_'</span> LUT_resolution <span class="string">'\'</span>];
0033 SetupInfo            = [<span class="string">'_'</span> num2str(f_low ) <span class="string">'Hz-'</span> <span class="keyword">...</span>
0034     num2str(f_high) <span class="string">'Hz_'</span> <span class="keyword">...</span>
0035     num2str(angle_pw) <span class="string">'pwAngle_'</span> <span class="keyword">...</span>
0036     num2str(Noise_Mask_dB) <span class="string">'dB_'</span> <span class="keyword">...</span>
0037     num2str(weight) <span class="string">'weight__with'</span> masker_type];
0038 Output_file_name     = [Input_file_name <span class="string">'__'</span> <span class="keyword">...</span>
0039     num2str(loudspeakers) <span class="string">'spkrs_'</span> <span class="keyword">...</span>
0040     SetupInfo];
0041 Output_file_ext      = <span class="string">'.WAV'</span>;
0042 
0043 
0044 
0045 
0046 
0047 <span class="comment">% Read input signal</span>
0048 Input_Signal = audioread( Input_file );
0049 
0050 <span class="keyword">for</span> sig = 1:3 <span class="comment">% Firstly we compute the loudspeaker signals for the input signal then we compute the loudspeaker signals for the additive zone weighted noise for the stereo pair</span>
0051     
0052     <span class="comment">%% First, Load the relevant look-up tables and check compatability</span>
0053     <span class="keyword">if</span> sig == 1
0054         load([Drive <span class="string">'+Soundfield_Database\+'</span> num2str(speaker_radius*2) <span class="string">'m_SpkrDia\+'</span> num2str(loudspeakers) <span class="string">'Spkrs_'</span> num2str(speaker_arc) <span class="string">'DegArc\LUT_Weight_vs_Frequency_'</span> num2str(angle_pw) <span class="string">'deg_'</span> LUT_resolution <span class="string">'.mat'</span>]);
0055     <span class="keyword">elseif</span> sig == 2
0056         load([Drive <span class="string">'+Soundfield_Database\+'</span> num2str(speaker_radius*2) <span class="string">'m_SpkrDia\+'</span> num2str(loudspeakers) <span class="string">'Spkrs_'</span> num2str(speaker_arc) <span class="string">'DegArc\LUT_Weight_vs_Frequency_'</span> num2str(leakage_angle_L) <span class="string">'deg_'</span> LUT_resolution <span class="keyword">...</span>
0057             <span class="string">'_zones_swapped.mat'</span>]);
0058     <span class="keyword">elseif</span> sig == 3
0059         load([Drive <span class="string">'+Soundfield_Database\+'</span> num2str(speaker_radius*2) <span class="string">'m_SpkrDia\+'</span> num2str(loudspeakers) <span class="string">'Spkrs_'</span> num2str(speaker_arc) <span class="string">'DegArc\LUT_Weight_vs_Frequency_'</span> num2str(leakage_angle_R) <span class="string">'deg_'</span> LUT_resolution <span class="keyword">...</span>
0060             <span class="string">'_zones_swapped.mat'</span>]);
0061     <span class="keyword">end</span>
0062     
0063     <span class="comment">%Loudspeaker capable LUT available?</span>
0064     <span class="keyword">if</span> ~exist(<span class="string">'Loudspeaker_Weights__Weight_Vs_Frequency'</span>,<span class="string">'var'</span>)
0065         error(<span class="string">'A Look-Up Table with valid Loudspeaker Weights was not found. Please either choose another LUT or generate a valid LUT.'</span>);
0066     <span class="keyword">end</span>
0067         
0068     <span class="comment">%% Second, Adjust the noise to account for the aliasing caused by a limited number of loudspeakers</span>
0069     <span class="comment">% The amount of aliasing is predicted from the average magnitude in the</span>
0070     <span class="comment">% quiet zone. Where there is a large amount of aliasing and hence a</span>
0071     <span class="comment">% large magnitude in the quiet zone, we invert this level and apply it</span>
0072     <span class="comment">% to the noise input signal.</span>
0073     <span class="keyword">if</span> (sig == 2) || (sig == 3)
0074         W = -mag2db(Quiet_Sample__Weight_Vs_Frequency);        
0075         freqs = linspace(0, Fs/2, length(Input_Signal)/2 + 1);
0076         freqs = freqs(freqs&gt;=min(Frequencies) &amp; freqs&lt;=max(Frequencies));
0077         W_ = permute( Tools.interpVal_2D(W, Frequencies, Weights, freqs, weight, <span class="string">'spline'</span>), [2 1]);        
0078         
0079         <span class="comment">% Equalise signal in target &quot;bright&quot; zone</span>
0080         Input_Signal = <a href="#_sub1" class="code" title="subfunction y = applyWeight(x, W, W_freqs, Fs)">applyWeight</a>(Input_Signal, W_, freqs, Fs);       
0081         
0082         <span class="comment">%Find cutoff frequencies for band pass filter</span>
0083         Alias_leakage_threshold = 7.5; <span class="comment">%dB</span>
0084         [~,bandpass_centre] = max(W_);
0085         f_cutoff_low  = freqs(find( W_(1:bandpass_centre) &lt;=Alias_leakage_threshold,1,<span class="string">'last'</span>));
0086         f_cutoff_high = freqs(find( W_(bandpass_centre:end) &lt;=Alias_leakage_threshold,1,<span class="string">'first'</span>));
0087         f_cutoff = [f_cutoff_low, f_cutoff_high];        
0088         
0089         <span class="comment">%Design low pass filter</span>
0090         [b,a] = butter(6, f_cutoff./(Fs/2));
0091         
0092         <span class="comment">%Apply low pass filter to noise</span>
0093         Input_Signal = filter(b,a,Input_Signal(:));
0094     <span class="keyword">end</span>
0095     
0096     
0097     <span class="comment">%% Third, find the frequency domain representation of the audio file that is wished to be reproduced in the spatial domain.</span>
0098     [Z, Frequencies_, ~, Windows] = Broadband_Tools.FFT_custom(Input_Signal, Nfft, Fs, overlap);
0099     
0100     <span class="comment">% Truncate to frequencies in the range f_low &lt;-&gt; f_high</span>
0101     trunc_index_low  = find(Frequencies_ &lt; f_low , 1, <span class="string">'last'</span> ) + 1;
0102     trunc_index_high = find(Frequencies_ &gt; f_high, 1 ) + 1;
0103     <span class="keyword">if</span> isempty(trunc_index_low)
0104         trunc_index_low = 1;
0105     <span class="keyword">end</span>
0106     <span class="keyword">if</span> isempty(trunc_index_high)
0107         trunc_index_high = length(Frequencies_);
0108     <span class="keyword">end</span>
0109     
0110     Frequencies_ = Frequencies_( :, trunc_index_low:trunc_index_high );
0111     
0112     
0113     <span class="comment">%% Fourth, build a flat spectra desired multizone soundfield for all frequencies from the previous fft and save the speaker weights for each frequency bin.</span>
0114     [szW, szF] = size(Loudspeaker_Weights__Weight_Vs_Frequency);
0115     LUT_Loudspeaker_Weights = cell2mat(Loudspeaker_Weights__Weight_Vs_Frequency);
0116     LUT_Loudspeaker_Weights = permute( reshape(LUT_Loudspeaker_Weights, loudspeakers, szW, szF), [2 3 1] );
0117     
0118     <span class="comment">% Find the weights that will give us the biggest contrast possible</span>
0119     <span class="comment">% (works better at lower frequencies)</span>
0120     <span class="comment">%LUT_MagDiff = Bright_Sample__Weight_Vs_Frequency - Quiet_Sample__Weight_Vs_Frequency;</span>
0121     <span class="comment">%Ideal_val = max(LUT_MagDiff(:))*ones(1,length(Frequencies_)); %Ideal value is the maximum separation</span>
0122    <span class="comment">% weights = Tools.interpFromVal_2D(LUT_MagDiff, Frequencies, Weights, Frequencies_, Ideal_val);</span>
0123             
0124     <span class="comment">% When interpolating the angle of the complex loudspeaker weight we need to phase unwrap otherwise</span>
0125     <span class="comment">% the interpolation may become close to 180 degrees out of phase which will</span>
0126     <span class="comment">% cause contructive interference instead of destructive and vise versa</span>
0127     Loudspeaker_Weights = zeros(length(Frequencies_),loudspeakers);
0128     <span class="keyword">for</span> spkr = 1:loudspeakers
0129         Loudspeaker_Weights(:,spkr) = permute( Tools.interpVal_2D(LUT_Loudspeaker_Weights(:,:,spkr), Frequencies, Weights, Frequencies_, weight, <span class="string">'spline'</span>), [2 1]);
0130         
0131         Loudspeaker_Weights(:,spkr) = permute( Tools.interpVal_2D(abs(LUT_Loudspeaker_Weights(:,:,spkr)), Frequencies, Weights, Frequencies_, weight, <span class="string">'spline'</span>), [2 1]) <span class="keyword">...</span>
0132             .* exp(1i * angle(Loudspeaker_Weights(:,spkr)));
0133         
0134     <span class="keyword">end</span>
0135     
0136 
0137     
0138     <span class="comment">%% Finally, apply the speaker weight and reconstruct the loudspeaker signals for each frame of the input signal</span>
0139     <span class="comment">% % Here we want to build the speaker signals for each speaker so that our loudspeaker weights are taken into account.</span>
0140     <span class="comment">% % We want to form the entire spectrum by adding the conjugate of the frame</span>
0141     <span class="comment">% % to the existing frame where the negative frequencies of the transform</span>
0142     <span class="comment">% % would usually exist.</span>
0143  Loudspeaker_Weights = [zeros(trunc_index_low-1, loudspeakers); <span class="keyword">...</span>
0144                         Loudspeaker_Weights; <span class="keyword">...</span>
0145                         zeros( size(Z,2) - trunc_index_high, loudspeakers)];                    
0146  Loudspeaker_Weights = permute( repmat(Loudspeaker_Weights, [1 1 size(Z,1)]), [3 1 2]);
0147  Z_l = repmat(Z, [1 1 loudspeakers]);
0148  
0149     <span class="comment">%</span>
0150     Loudspeakers_ = zeros( [size(Z_l,1) (size(Z_l,2))*2 size(Z_l,3)] );
0151     <span class="keyword">for</span> spkr = 1:loudspeakers
0152         Loudspeakers_(:,1:end/2,spkr) = Z_l(:,:,spkr) .* Loudspeaker_Weights(:,:,spkr);
0153         Loudspeakers_(:,end/2+1:<span class="keyword">end</span>,spkr) = conj( [-Loudspeakers_(:,1,spkr).*0 Loudspeakers_(:,end/2:-1:2,spkr)]);
0154     <span class="keyword">end</span>
0155     Original = [Z(:,:,1) conj( [-Z(:,1,1).*0 Z(:,end:-1:2,1)] )];
0156     <span class="comment">% clear Loudspeaker_Weights; % Save on memory</span>
0157     <span class="comment">%</span>
0158     <span class="comment">% % We then want to perform an Inverse FFT (ifft) on each full spectrum frame</span>
0159     <span class="keyword">for</span> frame = 1:size(Loudspeakers_, 1)
0160         <span class="keyword">for</span> spkr = 1:loudspeakers
0161             Loudspeakers_(frame,:,spkr) = ifft( Loudspeakers_(frame,:,spkr) );
0162         <span class="keyword">end</span>
0163         Original(frame,:) = ifft( Original(frame, :) );
0164     <span class="keyword">end</span>
0165     
0166     <span class="comment">%We should apply the second square root hamming window here</span>
0167     <span class="comment">%we should do this to remove artificats caused by our spectral</span>
0168     <span class="comment">%modification</span>
0169     <span class="comment">%for frame = 1:size(Loudspeakers_, 1)</span>
0170     <span class="keyword">for</span> spkr = 1:loudspeakers
0171         Loudspeakers_(:,:,spkr) = Loudspeakers_(:,:,spkr) .* Windows;
0172     <span class="keyword">end</span>
0173     Original = Original .* Windows;
0174     <span class="comment">%end</span>
0175     
0176     <span class="comment">%</span>
0177     <span class="comment">% % Then we should perform the overlap-add method to obtain the complete time domain signal for each speaker</span>
0178     <span class="comment">% %Loudspeaker_Signals =</span>
0179     <span class="comment">% zeros([(size(Z,1)+ceil(overlap))*size(Z,2)*2*(1-overlap) loudspeakers] ); % pre-allocate memory</span>
0180     <span class="keyword">for</span> spkr = 1:loudspeakers
0181         Loudspeaker_Signals(:,spkr) = Broadband_Tools.OverlapAdd( Loudspeakers_(:,:,spkr), overlap ); <span class="comment">%#ok&lt;AGROW&gt;</span>
0182     <span class="keyword">end</span>
0183     Original_ = Broadband_Tools.OverlapAdd( Original, overlap );
0184     <span class="comment">% clear Loudspeakers_; % Save on memory</span>
0185     
0186     
0187     <span class="comment">% Scale signals so they don't clip upon saving</span>
0188     <span class="keyword">if</span> Noise_Mask_dB &lt;= 0
0189         scaler = 1 / (db2mag(0)+1); <span class="comment">%Plus one is for the amplitude of the clean signal</span>
0190     <span class="keyword">elseif</span> Noise_Mask_dB &gt; 0 <span class="comment">% For a positive masker we scale the signals to save up to a 40db noise masker</span>
0191         scaler = 1 / (db2mag(40)+1);<span class="comment">%Plus one is for the amplitude of the clean signal</span>
0192     <span class="keyword">end</span>
0193     
0194     <span class="comment">% Normalise Loudspeaker Signals</span>
0195     Loudspeaker_Signals = Loudspeaker_Signals ./ max(abs(Loudspeaker_Signals(:)))  *  scaler; 
0196     Original_ = Original_ ./ max(abs(Original_(:)))  *  scaler;
0197     
0198     <span class="keyword">if</span> sig == 1
0199         Loudspeaker_Signals_Input_Signal = Loudspeaker_Signals;
0200         Original_Input_Signal = Original_;
0201     <span class="keyword">elseif</span> sig == 2
0202         Loudspeaker_Signals_Noise_L = Loudspeaker_Signals;
0203     <span class="keyword">elseif</span> sig == 3
0204         Loudspeaker_Signals_Noise_R = Loudspeaker_Signals;
0205     <span class="keyword">end</span>
0206     
0207     
0208     max_Spkrval =  max( abs( Loudspeaker_Signals_Input_Signal(:) ) );
0209     level_mag = db2mag(Noise_Mask_dB);
0210     Input_Signal = Perceptual_Tools.GreyNoise( length(Loudspeaker_Signals_Input_Signal)/Fs, Fs, max_Spkrval * level_mag );
0211     
0212 <span class="keyword">end</span>
0213 Original_ = Original_Input_Signal;
0214 
0215 
0216 <span class="comment">%% Add Stereo Zone Weighted Noise Loudspeaker Signals to Speech Loudspeaker Signals</span>
0217  <span class="comment">% Here we add our loudspeaker signals which reproduce our input signal and a relatively weighted stereo 'zone weighted' noise</span>
0218  <span class="comment">% That is to say, we add the stereo zone weighted noise to the reproduction,</span>
0219  <span class="comment">% however, the stereo zone weighted noise can be varied in level such that 0dB is</span>
0220  <span class="comment">% when the peak noise is equal to the input signal reproduction.</span>
0221 Loudspeaker_Signals = Loudspeaker_Signals_Input_Signal + db2mag(Noise_Mask_dB) * (Loudspeaker_Signals_Noise_L + Loudspeaker_Signals_Noise_R) / 2;
0222 
0223 
0224 
0225 <span class="comment">%% Once we have the speaker signals we should save them for later use as .wav files</span>
0226 filenumbers = num2str((1:loudspeakers)');
0227 filenumbers(filenumbers==<span class="string">' '</span>) = <span class="string">'_'</span>;
0228 fullpath = [repmat([Output_file_path Output_file_path_ext Output_file_name], [loudspeakers 1]) <span class="keyword">...</span>
0229     filenumbers <span class="keyword">...</span>
0230     repmat(Output_file_ext, [loudspeakers 1]) ];
0231 
0232 <span class="keyword">if</span> ~exist([Output_file_path Output_file_path_ext],<span class="string">'dir'</span>); mkdir([Output_file_path Output_file_path_ext]); <span class="keyword">end</span>
0233 
0234 <span class="keyword">for</span> spkr = 1:loudspeakers
0235     audiowrite(fullpath(spkr,:), Loudspeaker_Signals(:, spkr), Fs);
0236 <span class="keyword">end</span>
0237 audiowrite([Output_file_path Output_file_path_ext <span class="keyword">...</span>
0238     Input_file_name <span class="string">'__Original_'</span> <span class="keyword">...</span>
0239     num2str(f_low ) <span class="string">'Hz-'</span> <span class="keyword">...</span>
0240     num2str(f_high) <span class="string">'Hz'</span> <span class="keyword">...</span>
0241     Input_file_ext], Original_, Fs);
0242 
0243 
0244 
0245 
0246 <span class="keyword">end</span>
0247 
0248 <a name="_sub1" href="#_subfunctions" class="code">function y = applyWeight(x, W, W_freqs, Fs)</a>
0249 
0250 <span class="comment">% Frequency Domain Tranform</span>
0251 X = fft(x); <span class="comment">% Fast Fourier Transform</span>
0252 
0253 <span class="comment">% Frequencies</span>
0254 M = length(x);
0255 NumPts = M/2 + 1;
0256 freqs = linspace(0, Fs/2, NumPts);
0257 cutoff_low = min(W_freqs);
0258 cutoff_high = max(W_freqs);
0259 
0260 <span class="comment">% Weight Levels</span>
0261 W = [linspace(0, W(1), length(freqs(freqs&lt;cutoff_low))), <span class="keyword">...</span>
0262      W', <span class="keyword">...</span>
0263      linspace(W(end), 0, length(freqs(freqs&gt;cutoff_high)))];
0264 
0265 <span class="comment">% Apply magnitude weighting</span>
0266 X(1:NumPts) = X(1:NumPts) .* db2mag(W);
0267 
0268 <span class="comment">% Apply conjugation for negative frequency side of spectrum</span>
0269 X(NumPts+1:M) = conj(X(M/2:-1:2));
0270 
0271 <span class="comment">% Time Domain Transform</span>
0272 y = ifft(X); <span class="comment">% Inverse Fast Fourier Transform</span>
0273 
0274 <span class="comment">% prepare output vector y</span>
0275 y = real(y(1, 1:M));
0276 
0277 <span class="comment">% remove DC</span>
0278 y = y(:) - mean(y);
0279 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Sun 09-Jul-2017 20:35:18 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>