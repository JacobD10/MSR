<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of Clean_from_LUT_ZoneWeightedMask_AliasCtrl</title>
  <meta name="keywords" content="Clean_from_LUT_ZoneWeightedMask_AliasCtrl">
  <meta name="description" content="Clean_from_LUT_ZoneWeightedMask Summary of this function goes here">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">+Broadband_Tools</a> &gt; <a href="index.html">+Loudspeaker_Signal_Calculation</a> &gt; Clean_from_LUT_ZoneWeightedMask_AliasCtrl.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for +Broadband_Tools\+Loudspeaker_Signal_Calculation&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>Clean_from_LUT_ZoneWeightedMask_AliasCtrl
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Clean_from_LUT_ZoneWeightedMask Summary of this function goes here</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function Clean_from_LUT_ZoneWeightedMask_AliasCtrl( Input_file, LUT_resolution, Noise_Mask_dB, weight, setup, setup_mask ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">Clean_from_LUT_ZoneWeightedMask Summary of this function goes here
   Detailed explanation goes here</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function y = applyWeight(x, W, W_freqs, Fs)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function Clean_from_LUT_ZoneWeightedMask_AliasCtrl( Input_file, LUT_resolution, Noise_Mask_dB, weight, setup, setup_mask )</a>
0002 <span class="comment">%Clean_from_LUT_ZoneWeightedMask Summary of this function goes here</span>
0003 <span class="comment">%   Detailed explanation goes here</span>
0004 
0005 <span class="comment">%% Setup Variables</span>
0006 Drive = <span class="string">'Z:\'</span>;
0007 [Input_file_path, Input_file_name, Input_file_ext] = fileparts( Input_file );
0008 Input_file_path = [Input_file_path <span class="string">'\'</span>];
0009 
0010 signal_info.c = 343; <span class="comment">% Speed of sound in metres/sec</span>
0011 signal_info.Fs = 16000; <span class="comment">% Sampling frequency</span>
0012 signal_info.Nfft = 1024;<span class="comment">% Number of fft components</span>
0013 signal_info.overlap = 0.5;
0014 signal_info.f_low  = 150;  <span class="comment">% Hz</span>
0015 signal_info.f_high = 8000; <span class="comment">% Hz</span>
0016 signal_info.L_noise_mask = Noise_Mask_dB; <span class="comment">% dB</span>
0017 signal_info.weight = weight;
0018 signal_info.method = <span class="string">'ZoneWeightMaskAliasCtrl'</span>;
0019 signal_info.input_filename = Input_file_name;
0020 
0021 [Output_path, Output_file_name, Output_file_ext] = <span class="keyword">...</span>
0022     Broadband_Tools.getLoudspeakerSignalPath( setup, signal_info, LUT_resolution, Drive, <span class="string">'new'</span>);
0023 
0024 
0025 loudspeakers   = setup.Loudspeaker_Count;
0026 
0027 
0028 
0029 <span class="comment">% Read input signal</span>
0030 Input_Signal = audioread( Input_file );
0031 
0032 <span class="keyword">for</span> sig = 1:2 <span class="comment">% Firstly we compute the loudspeaker signals for the input signal then we compute the loudspeaker signals for the additive zone weighted noise</span>
0033     
0034     <span class="comment">%% First, Load the relevant look-up tables and check compatability</span>
0035     method = {<span class="string">'new4'</span>, <span class="string">'new3'</span>, <span class="string">'new2'</span>, <span class="string">'new'</span>};
0036     <span class="keyword">for</span> m = 1:2
0037         <span class="keyword">if</span> sig == 1
0038             method_ = [method, {<span class="string">'old'</span>}];
0039             [DB,err] = Soundfield_Database.loadDatabaseFromSetup( setup, LUT_resolution, Drive, method_{m} );
0040         <span class="keyword">elseif</span> sig == 2
0041             method_ = [method, {<span class="string">'old_zones_swapped'</span>}];
0042             [DB,err] = Soundfield_Database.loadDatabaseFromSetup( setup_mask, LUT_resolution, Drive, method_{m} );
0043         <span class="keyword">end</span>
0044         <span class="keyword">if</span> ~err
0045             <span class="keyword">break</span>;
0046         <span class="keyword">end</span>
0047     <span class="keyword">end</span>
0048     
0049     <span class="comment">%Loudspeaker capable LUT available?</span>
0050     <span class="keyword">if</span> ~isfield(DB,<span class="string">'Loudspeaker_Weights__Weight_Vs_Frequency'</span>)
0051         error(<span class="string">'A Look-Up Table with valid Loudspeaker Weights was not found. Please either choose another LUT or generate a valid LUT.'</span>);
0052     <span class="keyword">end</span>
0053     
0054     Frequencies = DB.Frequencies;
0055     Weights = DB.Weights;
0056     
0057     <span class="comment">%% Find ideal weights</span>
0058     single_weight = false;
0059     
0060     len = length(Input_Signal);
0061     noise_freqs = linspace(0, Fs/2, len/2 + 1);
0062     noise_freqs = noise_freqs(noise_freqs&gt;=min(Frequencies) &amp; noise_freqs&lt;=max(Frequencies));
0063     len = Nfft;
0064     freqs = linspace(0, Fs/2, len/2 + 1);
0065     freqs = freqs(freqs&gt;=min(Frequencies) &amp; freqs&lt;=max(Frequencies));
0066     
0067     <span class="keyword">if</span> single_weight
0068         noise_weights = repmat(weight,1,length(noise_freqs));
0069         weights = repmat(weight,1,length(freqs));
0070     <span class="keyword">else</span>
0071         <span class="comment">% Find the weights that will give us the biggest contrast possible</span>
0072         <span class="comment">% (works better at lower frequencies)</span>
0073         LUT_MagDiff = DB.Acoustic_Contrast__Weight_Vs_Frequency;<span class="comment">%DB.Bright_Sample__Weight_Vs_Frequency - DB.Quiet_Sample__Weight_Vs_Frequency;</span>
0074         
0075         <span class="comment">% Noise weights</span>
0076         LUT_MagDiff_interp = interp2(Frequencies,Weights,LUT_MagDiff,noise_freqs',Weights,<span class="string">'spline'</span>);
0077         [~,I]=max(LUT_MagDiff_interp);
0078         noise_weights = Weights(I);
0079         
0080         <span class="comment">%Signal Weights</span>
0081         LUT_MagDiff_interp = interp2(Frequencies,Weights,LUT_MagDiff,freqs',Weights,<span class="string">'spline'</span>);
0082         [~,I]=max(LUT_MagDiff_interp);
0083         weights = Weights(I);
0084     <span class="keyword">end</span>
0085     
0086     <span class="comment">%% Second, Adjust the noise to account for the aliasing caused by a limited number of loudspeakers</span>
0087     <span class="comment">% The amount of aliasing is predicted from the average magnitude in the</span>
0088     <span class="comment">% quiet zone. Where there is a large amount of aliasing and hence a</span>
0089     <span class="comment">% large magnitude in the quiet zone, we invert this level and apply it</span>
0090     <span class="comment">% to the noise input signal.</span>
0091     <span class="keyword">if</span> sig == 2
0092 <span class="comment">%         W = -mag2db(DB.Quiet_Sample__Weight_Vs_Frequency);</span>
0093 <span class="comment">%         W_ = permute( Tools.interpVal_2D(W, Frequencies, Weights, noise_freqs, noise_weights, 'spline'), [2 1]);</span>
0094 <span class="comment">%         W_=W_(:);</span>
0095         
0096         <span class="comment">% Equalise signal in target &quot;bright&quot; zone</span>
0097         <span class="comment">%Input_Signal = applyWeight(Input_Signal, W_, noise_freqs, Fs);</span>
0098         
0099         <span class="comment">%Find cutoff frequencies for band pass filter</span>
0100 <span class="comment">%         Alias_leakage_threshold = 7.5; %dB</span>
0101 <span class="comment">%         [~,bandpass_centre] = max(W_);</span>
0102 <span class="comment">%         f_cutoff_low  = noise_freqs(find( W_(1:bandpass_centre) &lt;=Alias_leakage_threshold,1,'last'));</span>
0103 <span class="comment">%         f_cutoff_high = noise_freqs( (bandpass_centre-1) + find( W_(bandpass_centre:end) &lt;=Alias_leakage_threshold,1,'first'));</span>
0104 <span class="comment">%         f_cutoff = [f_cutoff_low, f_cutoff_high];</span>
0105         R_ = max( [setup.Multizone_Soundfield.Bright_Zone.Radius_q + setup.Multizone_Soundfield.Bright_Zone.Origin_q.Distance; <span class="keyword">...</span>
0106                    setup.Multizone_Soundfield.Quiet_Zone.Radius_q + setup.Multizone_Soundfield.Quiet_Zone.Origin_q.Distance;  ]);
0107         phiL_rad = setup.Speaker_Arc_Angle / 180 * pi;
0108         
0109         f_cutoff = c * (loudspeakers - 1) / (2 * R_ * phiL_rad);
0110         
0111         <span class="comment">%Design low pass filter</span>
0112         [b,a] = butter(6, f_cutoff./(Fs/2));
0113         
0114         <span class="comment">%Apply low pass filter to noise</span>
0115         Input_Signal = filter(b,a,Input_Signal(:));
0116     <span class="keyword">end</span>
0117     
0118     
0119     <span class="comment">%% Third, find the frequency domain representation of the audio file that is wished to be reproduced in the spatial domain.</span>
0120     [Z, Frequencies_, ~, Windows] = Broadband_Tools.FFT_custom(Input_Signal, Nfft, Fs, overlap);
0121     
0122     <span class="comment">% Truncate to frequencies in the range f_low &lt;-&gt; f_high</span>
0123     trunc_index_low  = find(Frequencies_ &lt; f_low , 1, <span class="string">'last'</span> ) + 1;
0124     trunc_index_high = find(Frequencies_ &gt; f_high, 1 ) + 1;
0125     <span class="keyword">if</span> isempty(trunc_index_low)
0126         trunc_index_low = 1;
0127     <span class="keyword">end</span>
0128     <span class="keyword">if</span> isempty(trunc_index_high)
0129         trunc_index_high = length(Frequencies_);
0130     <span class="keyword">end</span>
0131     
0132     Frequencies_ = Frequencies_( :, trunc_index_low:trunc_index_high );
0133     
0134 <span class="comment">%     Frequencies_ = Frequencies_(Frequencies_&gt;=min(Frequencies) &amp; Frequencies_&lt;=max(Frequencies));</span>
0135     
0136     <span class="comment">%% Fourth, build a flat spectra desired multizone soundfield for all frequencies from the previous fft and save the speaker weights for each frequency bin.</span>
0137     [szW, szF] = size(DB.Loudspeaker_Weights__Weight_Vs_Frequency);
0138     LUT_Loudspeaker_Weights = cell2mat(DB.Loudspeaker_Weights__Weight_Vs_Frequency);
0139     LUT_Loudspeaker_Weights = permute( reshape(LUT_Loudspeaker_Weights, loudspeakers, szW, szF), [2 3 1] );    
0140     
0141     <span class="comment">% When interpolating the angle of the complex loudspeaker weight we need to phase unwrap otherwise</span>
0142     <span class="comment">% the interpolation may become close to 180 degrees out of phase which will</span>
0143     <span class="comment">% cause contructive interference instead of destructive and vise versa</span>
0144     Loudspeaker_Weights = zeros(length(Frequencies_),loudspeakers);
0145     <span class="keyword">for</span> spkr = 1:loudspeakers
0146         LW = Tools.interpVal_2D(LUT_Loudspeaker_Weights(:,:,spkr), Frequencies, Weights, Frequencies_, weights, <span class="string">'spline'</span>);
0147         Loudspeaker_Weights(:,spkr) = LW(:);
0148         
0149         LW_abs = Tools.interpVal_2D( abs(LUT_Loudspeaker_Weights(:,:,spkr)), Frequencies, Weights, Frequencies_, weights, <span class="string">'spline'</span>);
0150         Loudspeaker_Weights(:,spkr) = LW_abs(:) <span class="keyword">...</span>
0151             .* exp(1i * angle(Loudspeaker_Weights(:,spkr)));        
0152     <span class="keyword">end</span>
0153     
0154 
0155     
0156     <span class="comment">%% Finally, apply the speaker weight and reconstruct the loudspeaker signals for each frame of the input signal</span>
0157     <span class="comment">% % Here we want to build the speaker signals for each speaker so that our loudspeaker weights are taken into account.</span>
0158     <span class="comment">% % We want to form the entire spectrum by adding the conjugate of the frame</span>
0159     <span class="comment">% % to the existing frame where the negative frequencies of the transform</span>
0160     <span class="comment">% % would usually exist.</span>
0161  Loudspeaker_Weights = [zeros(trunc_index_low-1, loudspeakers); <span class="keyword">...</span>
0162                         Loudspeaker_Weights; <span class="keyword">...</span>
0163                         zeros( size(Z,2) - trunc_index_high, loudspeakers)];                    
0164  Loudspeaker_Weights = permute( repmat(Loudspeaker_Weights, [1 1 size(Z,1)]), [3 1 2]);
0165  Z_l = repmat(Z, [1 1 loudspeakers]);
0166  
0167     <span class="comment">%</span>
0168     Loudspeakers_ = zeros( [size(Z_l,1) (size(Z_l,2))*2 size(Z_l,3)] );
0169     <span class="keyword">for</span> spkr = 1:loudspeakers
0170         Loudspeakers_(:,1:end/2,spkr) = Z_l(:,:,spkr) .* Loudspeaker_Weights(:,:,spkr);
0171         Loudspeakers_(:,end/2+1:<span class="keyword">end</span>,spkr) = conj( [-Loudspeakers_(:,1,spkr).*0 Loudspeakers_(:,end/2:-1:2,spkr)]);
0172     <span class="keyword">end</span>
0173     Original = [Z(:,:,1) conj( [-Z(:,1,1).*0 Z(:,end:-1:2,1)] )];
0174     <span class="comment">% clear Loudspeaker_Weights; % Save on memory</span>
0175     <span class="comment">%</span>
0176     <span class="comment">% % We then want to perform an Inverse FFT (ifft) on each full spectrum frame</span>
0177     <span class="keyword">for</span> frame = 1:size(Loudspeakers_, 1)
0178         <span class="keyword">for</span> spkr = 1:loudspeakers
0179             Loudspeakers_(frame,:,spkr) = ifft( Loudspeakers_(frame,:,spkr) );
0180         <span class="keyword">end</span>
0181         Original(frame,:) = ifft( Original(frame, :) );
0182     <span class="keyword">end</span>
0183     
0184     <span class="comment">%We should apply the second square root hamming window here</span>
0185     <span class="comment">%we should do this to remove artificats caused by our spectral</span>
0186     <span class="comment">%modification</span>
0187     <span class="comment">%for frame = 1:size(Loudspeakers_, 1)</span>
0188     <span class="keyword">for</span> spkr = 1:loudspeakers
0189         Loudspeakers_(:,:,spkr) = Loudspeakers_(:,:,spkr) .* Windows;
0190     <span class="keyword">end</span>
0191     Original = Original .* Windows;
0192     <span class="comment">%end</span>
0193     
0194     <span class="comment">%</span>
0195     <span class="comment">% % Then we should perform the overlap-add method to obtain the complete time domain signal for each speaker</span>
0196     <span class="comment">% %Loudspeaker_Signals =</span>
0197     <span class="comment">% zeros([(size(Z,1)+ceil(overlap))*size(Z,2)*2*(1-overlap) loudspeakers] ); % pre-allocate memory</span>
0198     <span class="keyword">for</span> spkr = 1:loudspeakers
0199         Loudspeaker_Signals(:,spkr) = Broadband_Tools.OverlapAdd( Loudspeakers_(:,:,spkr), overlap ); <span class="comment">%#ok&lt;AGROW&gt;</span>
0200     <span class="keyword">end</span>
0201     Original_ = Broadband_Tools.OverlapAdd( Original, overlap );
0202     <span class="comment">% clear Loudspeakers_; % Save on memory</span>
0203     
0204     
0205     <span class="comment">% Scale signals so they don't clip upon saving</span>
0206     <span class="keyword">if</span> Noise_Mask_dB &lt;= 0
0207         scaler = 1 / (db2mag(0)+1); <span class="comment">%Plus one is for the amplitude of the clean signal</span>
0208     <span class="keyword">elseif</span> Noise_Mask_dB &gt; 0 <span class="comment">% For a positive masker we scale the signals to save up to a 40db noise masker</span>
0209         scaler = 1 / (db2mag(40)+1);<span class="comment">%Plus one is for the amplitude of the clean signal</span>
0210     <span class="keyword">end</span>
0211     
0212     <span class="comment">% Normalise Loudspeaker Signals</span>
0213     Loudspeaker_Signals = Loudspeaker_Signals ./ max(abs(Loudspeaker_Signals(:)))  *  scaler; 
0214     Original_ = Original_ ./ max(abs(Original_(:)))  *  scaler;
0215     
0216     <span class="keyword">if</span> sig == 1
0217         Loudspeaker_Signals_Input_Signal = Loudspeaker_Signals;
0218         Original_Input_Signal = Original_;
0219     <span class="keyword">end</span>
0220     
0221     <span class="comment">%Input_Signal = Tools.generateNoise(Loudspeaker_Signals, Noise_Mask_dB, 'WGN'); % Generate noise to put back into the system and zone weight according to the multizone setup</span>
0222     max_Spkrval =  max( abs( Loudspeaker_Signals(:) ) );
0223     level_mag = db2mag(Noise_Mask_dB);
0224     Input_Signal = Perceptual_Tools.GreyNoise( length(Loudspeaker_Signals)/Fs, Fs, max_Spkrval * level_mag );
0225     Input_Signal = Input_Signal(:);
0226 <span class="keyword">end</span>
0227 Original_ = Original_Input_Signal;
0228 
0229 
0230 <span class="comment">%% Add Zone Weighted Noise Loudspeaker Signals to Speech Loudspeaker Signals</span>
0231  <span class="comment">% Here we add our loudspeaker signals which reproduce our input signal and a relatively weighted 'zone weighted' noise</span>
0232  <span class="comment">% That is to say, we add the zone weighted noise to the reproduction,</span>
0233  <span class="comment">% however, the zone weighted noise can be varied in level such that 0dB is</span>
0234  <span class="comment">% when the peak noise is equal to the input signal reproduction.</span>
0235 Loudspeaker_Signals = Loudspeaker_Signals_Input_Signal + db2mag(Noise_Mask_dB) * Loudspeaker_Signals;
0236 
0237 
0238 
0239 
0240 
0241 
0242 <span class="comment">%% Once we have the speaker signals we should save them for later use as .wav files</span>
0243 filenumbers = num2str((1:loudspeakers)');
0244 filenumbers(filenumbers==<span class="string">' '</span>) = <span class="string">'_'</span>;
0245 fullpath = [repmat([Output_path Output_file_name], [loudspeakers 1]) <span class="keyword">...</span>
0246     filenumbers <span class="keyword">...</span>
0247     repmat(Output_file_ext, [loudspeakers 1]) ];
0248 
0249 <span class="keyword">if</span> ~exist(Output_path,<span class="string">'dir'</span>); mkdir(Output_path); <span class="keyword">end</span>
0250 
0251 <span class="keyword">for</span> spkr = 1:loudspeakers
0252     audiowrite(fullpath(spkr,:), Loudspeaker_Signals(:, spkr), Fs);
0253 <span class="keyword">end</span>
0254 audiowrite([Output_path <span class="keyword">...</span>
0255     Input_file_name <span class="string">'_'</span> <span class="string">'Original'</span>
0256     Input_file_ext], Original_, Fs);
0257 
0258 
0259 
0260 
0261 <span class="keyword">end</span>
0262 
0263 <a name="_sub1" href="#_subfunctions" class="code">function y = applyWeight(x, W, W_freqs, Fs)</a>
0264 
0265 <span class="comment">% Frequency Domain Tranform</span>
0266 X = fft(x); <span class="comment">% Fast Fourier Transform</span>
0267 
0268 <span class="comment">% Frequencies</span>
0269 M = length(x);
0270 NumPts = M/2 + 1;
0271 freqs = linspace(0, Fs/2, NumPts);
0272 cutoff_low = min(W_freqs);
0273 cutoff_high = max(W_freqs);
0274 
0275 <span class="comment">% Weight Levels</span>
0276 W = [linspace(0, W(1), length(freqs(freqs&lt;cutoff_low))), <span class="keyword">...</span>
0277      W(:)', <span class="keyword">...</span>
0278      linspace(W(end), 0, length(freqs(freqs&gt;cutoff_high)))];
0279 
0280 <span class="comment">% Apply magnitude weighting</span>
0281 X(1:NumPts) = X(1:NumPts) .* db2mag(W(:));
0282 
0283 <span class="comment">% Apply conjugation for negative frequency side of spectrum</span>
0284 X(NumPts+1:M) = conj(X(M/2:-1:2));
0285 
0286 <span class="comment">% Time Domain Transform</span>
0287 y = ifft(X); <span class="comment">% Inverse Fast Fourier Transform</span>
0288 
0289 <span class="comment">% prepare output vector y</span>
0290 y = real(y(1:M));
0291 
0292 <span class="comment">% remove DC</span>
0293 y = y(:) - mean(y);
0294 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Sun 09-Jul-2017 20:35:18 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>