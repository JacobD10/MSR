<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of stoi</title>
  <meta name="keywords" content="stoi">
  <meta name="description" content="STOI The Short-Time Objective Intelligibility measure">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">+Tools</a> &gt; stoi.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for +Tools&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>stoi
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>STOI The Short-Time Objective Intelligibility measure</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function d = stoi(x, y, fs_signal) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">STOI The Short-Time Objective Intelligibility measure 
   d = stoi(x, y, fs_signal) returns the output of the short-time
   objective intelligibility (STOI) measure described in [1, 2], where x 
   and y denote the clean and processed speech, respectively, with sample
   rate fs_signal in Hz. The output d is expected to have a monotonic 
   relation with the subjective speech-intelligibility, where a higher d 
   denotes better intelligible speech. See [1, 2] for more details.

   References:
      [1] C.H.Taal, R.C.Hendriks, R.Heusdens, J.Jensen 'A Short-Time
      Objective Intelligibility Measure for Time-Frequency Weighted Noisy
      Speech', ICASSP 2010, Texas, Dallas.

      [2] C.H.Taal, R.C.Hendriks, R.Heusdens, J.Jensen 'An Algorithm for 
      Intelligibility Prediction of Time-Frequency Weighted Noisy Speech', 
      IEEE Transactions on Audio, Speech, and Language Processing, 2011. 


 Copyright 2009: Delft University of Technology, Signal &amp; Information
 Processing Lab. The software is free for non-commercial use. This program
 comes WITHOUT ANY WARRANTY.



 Updates:
 2011-04-26 Using the more efficient 'taa_corr' instead of 'corr'</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function  [A cf] = thirdoct(fs, N_fft, numBands, mn)</a></li><li><a href="#_sub2" class="code">function x_stdft = stdft(x, N, K, N_fft)</a></li><li><a href="#_sub3" class="code">function [x_sil y_sil] = removeSilentFrames(x, y, range, N, K)</a></li><li><a href="#_sub4" class="code">function rho = taa_corr(x, y)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function d = stoi(x, y, fs_signal)</a>
0002 <span class="comment">%STOI The Short-Time Objective Intelligibility measure</span>
0003 <span class="comment">%   d = stoi(x, y, fs_signal) returns the output of the short-time</span>
0004 <span class="comment">%   objective intelligibility (STOI) measure described in [1, 2], where x</span>
0005 <span class="comment">%   and y denote the clean and processed speech, respectively, with sample</span>
0006 <span class="comment">%   rate fs_signal in Hz. The output d is expected to have a monotonic</span>
0007 <span class="comment">%   relation with the subjective speech-intelligibility, where a higher d</span>
0008 <span class="comment">%   denotes better intelligible speech. See [1, 2] for more details.</span>
0009 <span class="comment">%</span>
0010 <span class="comment">%   References:</span>
0011 <span class="comment">%      [1] C.H.Taal, R.C.Hendriks, R.Heusdens, J.Jensen 'A Short-Time</span>
0012 <span class="comment">%      Objective Intelligibility Measure for Time-Frequency Weighted Noisy</span>
0013 <span class="comment">%      Speech', ICASSP 2010, Texas, Dallas.</span>
0014 <span class="comment">%</span>
0015 <span class="comment">%      [2] C.H.Taal, R.C.Hendriks, R.Heusdens, J.Jensen 'An Algorithm for</span>
0016 <span class="comment">%      Intelligibility Prediction of Time-Frequency Weighted Noisy Speech',</span>
0017 <span class="comment">%      IEEE Transactions on Audio, Speech, and Language Processing, 2011.</span>
0018 <span class="comment">%</span>
0019 <span class="comment">%</span>
0020 <span class="comment">% Copyright 2009: Delft University of Technology, Signal &amp; Information</span>
0021 <span class="comment">% Processing Lab. The software is free for non-commercial use. This program</span>
0022 <span class="comment">% comes WITHOUT ANY WARRANTY.</span>
0023 <span class="comment">%</span>
0024 <span class="comment">%</span>
0025 <span class="comment">%</span>
0026 <span class="comment">% Updates:</span>
0027 <span class="comment">% 2011-04-26 Using the more efficient 'taa_corr' instead of 'corr'</span>
0028 
0029 <span class="keyword">if</span> length(x)~=length(y)
0030     error(<span class="string">'x and y should have the same length'</span>);
0031 <span class="keyword">end</span>
0032 
0033 <span class="comment">% initialization</span>
0034 x           = x(:);                             <span class="comment">% clean speech column vector</span>
0035 y           = y(:);                             <span class="comment">% processed speech column vector</span>
0036 
0037 fs          = 10000;                            <span class="comment">% sample rate of proposed intelligibility measure</span>
0038 N_frame        = 256;                              <span class="comment">% window support</span>
0039 K           = 512;                              <span class="comment">% FFT size</span>
0040 J           = 15;                               <span class="comment">% Number of 1/3 octave bands</span>
0041 mn          = 150;                              <span class="comment">% Center frequency of first 1/3 octave band in Hz.</span>
0042 H           = <a href="#_sub1" class="code" title="subfunction  [A cf] = thirdoct(fs, N_fft, numBands, mn)">thirdoct</a>(fs, K, J, mn);           <span class="comment">% Get 1/3 octave band matrix</span>
0043 N           = 30;                               <span class="comment">% Number of frames for intermediate intelligibility measure (Length analysis window)</span>
0044 Beta        = -15;                               <span class="comment">% lower SDR-bound</span>
0045 dyn_range   = 40;                               <span class="comment">% speech dynamic range</span>
0046 
0047 <span class="comment">% resample signals if other samplerate is used than fs</span>
0048 <span class="keyword">if</span> fs_signal ~= fs
0049     x    = resample(x, fs, fs_signal);
0050     y     = resample(y, fs, fs_signal);
0051 <span class="keyword">end</span>
0052 
0053 <span class="comment">% remove silent frames</span>
0054 [x y] = <a href="#_sub3" class="code" title="subfunction [x_sil y_sil] = removeSilentFrames(x, y, range, N, K)">removeSilentFrames</a>(x, y, dyn_range, N_frame, N_frame/2);
0055 
0056 <span class="comment">% apply 1/3 octave band TF-decomposition</span>
0057 x_hat         = <a href="#_sub2" class="code" title="subfunction x_stdft = stdft(x, N, K, N_fft)">stdft</a>(x, N_frame, N_frame/2, K);     <span class="comment">% apply short-time DFT to clean speech</span>
0058 y_hat         = <a href="#_sub2" class="code" title="subfunction x_stdft = stdft(x, N, K, N_fft)">stdft</a>(y, N_frame, N_frame/2, K);     <span class="comment">% apply short-time DFT to processed speech</span>
0059 
0060 x_hat       = x_hat(:, 1:(K/2+1)).';             <span class="comment">% take clean single-sided spectrum</span>
0061 y_hat       = y_hat(:, 1:(K/2+1)).';            <span class="comment">% take processed single-sided spectrum</span>
0062 
0063 X           = zeros(J, size(x_hat, 2));         <span class="comment">% init memory for clean speech 1/3 octave band TF-representation</span>
0064 Y           = zeros(J, size(y_hat, 2));         <span class="comment">% init memory for processed speech 1/3 octave band TF-representation</span>
0065 
0066 <span class="keyword">for</span> i = 1:size(x_hat, 2)
0067     X(:, i)    = sqrt(H*abs(x_hat(:, i)).^2);      <span class="comment">% apply 1/3 octave bands as described in Eq.(1) [1]</span>
0068     Y(:, i)    = sqrt(H*abs(y_hat(:, i)).^2);
0069 <span class="keyword">end</span>
0070 
0071 <span class="comment">% loop al segments of length N and obtain intermediate intelligibility measure for all TF-regions</span>
0072 d_interm      = zeros(J, length(N:size(X, 2)));                               <span class="comment">% init memory for intermediate intelligibility measure</span>
0073 c           = 10^(-Beta/20);                                                <span class="comment">% constant for clipping procedure</span>
0074 
0075 <span class="keyword">for</span> m = N:size(X, 2)
0076     X_seg      = X(:, (m-N+1):m);                                              <span class="comment">% region with length N of clean TF-units for all j</span>
0077     Y_seg      = Y(:, (m-N+1):m);                                              <span class="comment">% region with length N of processed TF-units for all j</span>
0078     alpha   = sqrt(sum(X_seg.^2, 2)./sum(Y_seg.^2, 2));                     <span class="comment">% obtain scale factor for normalizing processed TF-region for all j</span>
0079     aY_seg     = Y_seg.*repmat(alpha, [1 N]);                                   <span class="comment">% obtain \alpha*Y_j(n) from Eq.(2) [1]</span>
0080     <span class="keyword">for</span> j = 1:J
0081           Y_prime             = min(aY_seg(j, :), X_seg(j, :)+X_seg(j, :)*c); <span class="comment">% apply clipping from Eq.(3)</span>
0082         d_interm(j, m-N+1)  = <a href="#_sub4" class="code" title="subfunction rho = taa_corr(x, y)">taa_corr</a>(X_seg(j, :).', Y_prime(:));          <span class="comment">% obtain correlation coeffecient from Eq.(4) [1]</span>
0083     <span class="keyword">end</span>
0084 <span class="keyword">end</span>
0085         
0086 d = mean(d_interm(:));                                                      <span class="comment">% combine all intermediate intelligibility measures as in Eq.(4) [1]</span>
0087 
0088 <span class="comment">%%</span>
0089 <a name="_sub1" href="#_subfunctions" class="code">function  [A cf] = thirdoct(fs, N_fft, numBands, mn)</a>
0090 <span class="comment">%   [A CF] = THIRDOCT(FS, N_FFT, NUMBANDS, MN) returns 1/3 octave band matrix</span>
0091 <span class="comment">%   inputs:</span>
0092 <span class="comment">%       FS:         samplerate</span>
0093 <span class="comment">%       N_FFT:      FFT size</span>
0094 <span class="comment">%       NUMBANDS:   number of bands</span>
0095 <span class="comment">%       MN:         center frequency of first 1/3 octave band</span>
0096 <span class="comment">%   outputs:</span>
0097 <span class="comment">%       A:          octave band matrix</span>
0098 <span class="comment">%       CF:         center frequencies</span>
0099 
0100 f               = linspace(0, fs, N_fft+1);
0101 f               = f(1:(N_fft/2+1));
0102 k               = 0:(numBands-1); 
0103 cf              = 2.^(k/3)*mn;
0104 fl              = sqrt((2.^(k/3)*mn).*2.^((k-1)/3)*mn);
0105 fr              = sqrt((2.^(k/3)*mn).*2.^((k+1)/3)*mn);
0106 A               = zeros(numBands, length(f));
0107 
0108 <span class="keyword">for</span> i = 1:(length(cf))
0109     [a b]                   = min((f-fl(i)).^2);
0110     fl(i)                   = f(b);
0111     fl_ii                   = b;
0112 
0113     [a b]                   = min((f-fr(i)).^2);
0114     fr(i)                   = f(b);
0115     fr_ii                   = b;
0116     A(i,fl_ii:(fr_ii-1))    = 1;
0117 <span class="keyword">end</span>
0118 
0119 rnk         = sum(A, 2);
0120 numBands      = find((rnk(2:end)&gt;=rnk(1:(end-1))) &amp; (rnk(2:end)~=0)~=0, 1, <span class="string">'last'</span> )+1;
0121 A           = A(1:numBands, :);
0122 cf          = cf(1:numBands);
0123 
0124 <span class="comment">%%</span>
0125 <a name="_sub2" href="#_subfunctions" class="code">function x_stdft = stdft(x, N, K, N_fft)</a>
0126 <span class="comment">%   X_STDFT = X_STDFT(X, N, K, N_FFT) returns the short-time</span>
0127 <span class="comment">%    hanning-windowed dft of X with frame-size N, overlap K and DFT size</span>
0128 <span class="comment">%   N_FFT. The columns and rows of X_STDFT denote the frame-index and</span>
0129 <span class="comment">%   dft-bin index, respectively.</span>
0130 
0131 frames      = 1:K:(length(x)-N);
0132 x_stdft     = zeros(length(frames), N_fft);
0133 
0134 w           = hanning(N);
0135 x           = x(:);
0136 
0137 <span class="keyword">for</span> i = 1:length(frames)
0138     ii              = frames(i):(frames(i)+N-1);
0139     x_stdft(i, :)     = fft(x(ii).*w, N_fft);
0140 <span class="keyword">end</span>
0141 
0142 <span class="comment">%%</span>
0143 <a name="_sub3" href="#_subfunctions" class="code">function [x_sil y_sil] = removeSilentFrames(x, y, range, N, K)</a>
0144 <span class="comment">%   [X_SIL Y_SIL] = REMOVESILENTFRAMES(X, Y, RANGE, N, K) X and Y</span>
0145 <span class="comment">%   are segmented with frame-length N and overlap K, where the maximum energy</span>
0146 <span class="comment">%   of all frames of X is determined, say X_MAX. X_SIL and Y_SIL are the</span>
0147 <span class="comment">%   reconstructed signals, excluding the frames, where the energy of a frame</span>
0148 <span class="comment">%   of X is smaller than X_MAX-RANGE</span>
0149 
0150 x       = x(:);
0151 y       = y(:);
0152 
0153 frames  = 1:K:(length(x)-N);
0154 w       = hanning(N);
0155 msk     = zeros(size(frames));
0156 
0157 <span class="keyword">for</span> j = 1:length(frames)
0158     jj      = frames(j):(frames(j)+N-1);
0159     msk(j)     = 20*log10(norm(x(jj).*w)./sqrt(N));
0160 <span class="keyword">end</span>
0161 
0162 msk     = (msk-max(msk)+range)&gt;0;
0163 count   = 1;
0164 
0165 x_sil   = zeros(size(x));
0166 y_sil   = zeros(size(y));
0167 
0168 <span class="keyword">for</span> j = 1:length(frames)
0169     <span class="keyword">if</span> msk(j)
0170         jj_i            = frames(j):(frames(j)+N-1);
0171         jj_o            = frames(count):(frames(count)+N-1);
0172         x_sil(jj_o)     = x_sil(jj_o) + x(jj_i).*w;
0173         y_sil(jj_o)      = y_sil(jj_o) + y(jj_i).*w;
0174         count           = count+1;
0175     <span class="keyword">end</span>
0176 <span class="keyword">end</span>
0177 
0178 x_sil = x_sil(1:jj_o(end));
0179 y_sil = y_sil(1:jj_o(end));
0180 
0181 <span class="comment">%%</span>
0182 <a name="_sub4" href="#_subfunctions" class="code">function rho = taa_corr(x, y)</a>
0183 <span class="comment">%   RHO = TAA_CORR(X, Y) Returns correlation coeffecient between column</span>
0184 <span class="comment">%   vectors x and y. Gives same results as 'corr' from statistics toolbox.</span>
0185 xn        = x-mean(x);
0186 xn      = xn/sqrt(sum(xn.^2));
0187 yn       = y-mean(y);
0188 yn        = yn/sqrt(sum(yn.^2));
0189 rho       = sum(xn.*yn);</pre></div>
<hr><address>Generated on Sun 09-Jul-2017 20:35:18 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>